# 190311 List

### 리스트

- 순차 리스트 : 배열을 기반으로 구현된 리스트
- 연결 리스트 : 메모리의 동적 할당을 기반으로 구현된 리스트
- 순차나 연결 둘 다 C를 안 한 사람은 이해하기 어려운 부분(안 배워서)



#### 리스트의 주요 함수

| 함수명       | 기능                                         |
| ------------ | -------------------------------------------- |
| addtoFirst() | 리스트 앞쪽에 원소를 추가                    |
| addtoLast()  | 리스트 뒤쪽에 원소를 추가                    |
| add()        | 리스트 특정 위치에 원소를 추가               |
| delete()     | 리스트 특정 위치(혹은 값)에 있는 원소를 삭제 |
| get()        | 리스트 특정 위치에 있는 원소를 리턴          |



#### 순차 리스트

- 구현 방법 : 1차원 배열에 항목들을 순서대로 저장.
- 삽입 연산 : 집어 넣을 index부터 끝까지의 값을 모두 +1해서 옮긴 후 삽입.
- 삭제 연한 : 삭제한 index 오른쪽 값부터 끝까지의 값을 모두 -1해서 옮겨야 한다.
- **==시간이 오래 걸리고 메모리가 많이 사용되는 단점==**



#### 연결 리스트

- 실제 저장된 상태는 여러 군데에 각각 있는 것이지만 개념적으로는 연결된 것처럼 사용
- 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않는다.
- 링크를 통해 값에 접근하기 때문에 순차 리스트처럼 작업이 필요하지 않고, 자료 구조의 크기를 동적으로 조정할 수 있어서 메모리 사용이 효율적

#### 연결 리스트의 기본 구조

**노드**

- 데이터 필드 : 원소의 값을 저장하는 자료 구조, 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용
- 링크 필드 : 다음 노드의 주소를 저장하는 자료 구조

**헤드**

- 리스트의 처음 노드를 가리키는 레퍼런스



#### 단순 연결 리스트(Singly Linked List)

**연결 구조**

- 모든 노드는 자기 다음에 와야 할 노드의 정보를 가지고 있다.(그 외에는 신경 안 씀)
- NULL을 가리키는 노드가 리스트의 가장 마지막 노드

**단순 연결 리스트의 삽입 연산**

- 새로운 값을 가진 노드를 생성한다.
- 끼워 넣을 위치의 이전 노드가 가리키는 노드 정보를 새로운 노드에 저장한다.
- 끼워 넣을 위치의 이전 노드가 가리키는 노드 정보를 새로운 노드로 변경한다.

**단순 연결 리스트의 삭제 연산**

- 삽입 연산과 마찬가지로 삭제할 노드 이전의 노드를 알고 있어야 한다.
- 삭제할 노드의 링크(가리키는 노드 정보)를 이전 노드의 링크 필드에 입력해줘야 한다.



#### 이중 연결 리스트(Doubly Linked List)

**연결 구조**

- 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
- 이전, 이후를 알 수 있는 두 개의 링크 필드와 한 개의 데이터 필드로 구성됨.
- 단순 연결 리스트와 다르게 첫 번째 리스트의 이전 링크 필드와 마지막 리스트의 다음 링크 필드가 Null이다.

**이중 연결 리스트의 삽입 연산**

- 새로운 값을 가진 노드를 생성하고 링크 정보를 저장한다.
- 끼워 넣을 위치의 이전 노드가 가리키는 다음 노드 정보를 새로운 노드의 다음 링크 필드에 입력한다.
- 끼워 넣을 위치의 다음 노드가 가리키는 이전 노드 정보를 새로운 노드의 이전 링크 필드에 입력한다.
- 끼워 넣을 위치의 이전 노드의 다음 노드 정보와 다음 노드의 이전 노드 정보를 새로운 노드의 링크로 변경한다.

**이중 연결 리스트의 삭제 연산** 

- 삭제할 노드의 링크 정보를 저장한다.
- 삭제할 노드의 다음 노드 링크를 이전 노드의 다음 노드 링크에 저장한다.
- 삭제할 노드의 이전 노드 링크를 다음 노드의 이전 노드 링크에 저장한다.





### 삽입 정렬(Insertion Sort)

**정렬 과정**

- 정렬할 자료를 두 개의 부분 집합 S와 U로 가정.
  - S : 정렬된 앞 부분의 원소들, S : 아직 정렬되지 않은 원소들
- 정렬되지 않은 부분 집합 U의 원소를 하나씩 꺼내서 정렬된 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입
- 작업이 반복되면서 S는 원소가 하나씩 늘어나고 U는 하나씩 감소, U가 공집합이 되면 삽입 정렬 완성
- 시간 복잡도 O(n^2^)

- 삽입 정렬은 연결 리스트일 경우에 다른 O(n) 작업보다 효율적
- 굳이 쓸 일은 없을 듯





### 병합 정렬(Merge Sort)

- 배열보다 연결 리스트 형태로 되어 있을 때 효율적
- 모든 리스트를 1개가 될 때까지 나눈다.(예, `[69][10][30][2][16][8][31][22]`)
- 2개씩 비교해서 정렬한다.(`[10, 69][2, 30][8, 16][22, 31]`)
- 정렬된 리스트의 같은 index를 비교해서 정렬해준다.(`[10]`과 `[2]` 비교 후 정렬, `[69]`와 `[30]` 비교 후 정렬)
- 3, 4를 반복한다.



### 리스트를 이용한 스택

### 우선순위 큐(Priority Queue)

