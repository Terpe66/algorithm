### 프로그래밍 언어의 종류

- 컴퓨터의 동작을 제어하려면 ==CPU가 이해하는 기계어 코드를 생성==해야 함
- 기계어 코드로 프로그래밍 하기에는 너무 어렵기 때문에 ==프로그래밍 언어를 이용하여 프로그램 작성==



**저급 언어**

- 컴퓨터의 CPU가 해석하기 쉽게 만들어진 프로그램이 언어로 CPU 종속적

- 예 : Intel i7 Processor 기반의 어셈블리 프로그램

  ```assembly
  mov -0x8(%rbp),%eax
  test %eax,%eax
  jle 400517 <main+0x33>
  addl $0x1, -0x4(%rbp)
  ```

**고급 언어**

- 사람이 해석하기 쉽게 만들어진 프로그램

- 절차적 언어 : BASIC, COBOL, FORTRAN

- 구조적 언어 : PASCAL, C

- 객체지향 언어 : C++, JAVA, C#, Visual Basic, .NET

  ```C
  if (count > 0)
      ++count;
  ```



### C 언어의 역사

- ALGOL60
  - 구조화된 프로그램 언어의 효시(맨 처음 작)
- CPL(Combined Programming Language)
  - 1963년 영국 켐브릿지 대학에서 개발
- BCPL(Basic CPL)
  - 1970년 켐브릿지 대학 Martin Richard가 발전
- B Language
  - Unix 운영체제 개발자인 켄 톰슨이 발전시킴
  - 바이트 처리가 지원되지 않아 Unix 운영체제에 이용 불가

- C Language
  - 바이트 처리, 구조체 지원 기능 등이 추가되며 1972년 탄생



### C 언어의 사용

`운영체제를 기술하는 언어`, `하드웨어 제어 프로그램`, `시스템 프로그램`, `일반 응용 프로그램`에 광범위하게 이용



### C 언어의 특징

- 시스템 기반의 프로그램 작성에 적합한 언어
  - 비트 단위의 연산 가능
  - 포인터를 이용한 메모리에 대한 접근이 용이함
  - 자료 형 변환이 자유로움
  - 여러 기종 간의 이식성이 뛰어남
- 범용 프로그램 작성에 적합한 언어
  - 풍부한 자료형 지원과 다양한 연산자 제공
  - 구조적 프로그램 언어로 모듈(함수) 방식 제어 구조
  - 다양한 라이브러리 제공
  - 동적 메모리를 활용한 효율적인 자료처리
- 저급 프로그래밍언어와 고급 프로그램잉언어의 양면성
  - 어셈블리 언어와의 연동 가능
  - 하드웨어에 최적화된 프로그램 가능
- 간결한 구조의 언어이면서도 정확한 제어구조와 자료 형 표현

- 1983년 미국 국가 표준협회에서 ANSI C 발표, C 컴파일러는 ANSI C 표준안에 맞춰 작성
  - 컴파일러 : 고급 언어(high level language)로 작성된 프로그램을 컴퓨터가 실행할 수 있도록 기계어로 변환시켜주는 도구



### C 언어의 사용 분야

- 운영체제의 핵심, 커널
  - CPU, 메모리, 하드디스크 등과 같은 하드웨어 자원을 관리하는 커널
  - 각 운영체제의 커널을 C 언어로 작성

- 임베디드 시스템, 하드웨어 제어
  - 저급언어 : 하드웨어를 제어하기 쉬움
  - 각종 장치들의 지능화로 좀 더 정밀하고 고도화된 하드웨어 제어 프로그램이 필요해졌고, C 언어가 필수
- 시스템 기반의 프로그램, 웹 서버
  - 운영체제에서 제공하는 기능은 시스템 API로 구현
  - 시스템 API는 C 언어 함수로 구현되어 있어, 시스템 기반의 프로그램들은 C 언어로 작성하는 것이 최적
  - FTP 서버나 텔넷 서버 등 각종 인터넷 서버
  - 온라인 게임 서버와 같이 속도에 민감한 프로그램
  - 보안에 관련된 프로그램이나 컴파일러와 같은 시스템 의존적인 프로그램

**하드웨어 제어 분야, 시스템 API를 직접 다루는 경우, 속도가 중요한 경우 사용**



### C 프로그램 개발 과정

- 소스코드 작성 및 수정
  - 소스 코드 편집기를 이용하여 C 언어 문법에 맞는 프로그램 작성
  - 확장자는 .c
- 컴파일 & 링킹
  - C 컴퍼일러를 통해 ==소스 코드의 문제점을 확인==하는 과정
    - 정상적으로 컴파일 되면 오브젝트 파일(.obj) 생성
  - 링커에 의해 오브젝트 파일을 실행 가능한 실행파일로 링크
    - 윈도우에선 .exe 확장자, 리눅스, 유닉스는 확장자 X
- 테스트
  - 컴파일 & 링크 과정에서 생성한 실행 파일이 설계대로 수행되는지를 시험
- 디버깅
  - 테스트 과정에서 설계대로 동작되지 않는 기능이 있는 경우 원인 확인과 변경
    - 필요 시 소스 코드 수정



### C 언어 함수의 형식

`리턴_자료형` `함수_이름`(`매개변수 목록`)

{

​	`명령문1;`

​	`명령문2;`

​	`...`

​	`명령문N;`

}

- 리턴_자료형 : 함수에서 반환하는 값의 자료형
- 함수_이름 : 영문 대소문자와 _(underscore)만 사용 가능. 숫자는 첫 글자로 불가능. 대소문자 구분
- 매개변수 목록 : 함수를 호출할 때 전달되는 값들을 받아올 변수, 없을 경우 생략



### main 함수

- C 프로그램 실행 시 최초로 호출되는 함수
- 프로그램이 실행될 때 main 함수에 포함된 명령문들을 제일 먼저 수행
- 프로그램 작성 시 반드시 구성해야 할 함수
- 프로그램 내에는 반드시 한 개의 main 함수만 있어야 함



### 표준 입출력 함수

- C 언어 프로그램의 입출력은 모두 ==스트림(stream)==을 통해 이루어짐
  - 스트림 : 일련의 바이트로 구성된 데이터의 흐름으로 장치의 종류와 관계없이 ==동일한 방법==으로 입출력을 수행



### 입출력장치와 스트림의 관계

- #include <stdio.h>

  키보드 => `stdin` => `실행 프로그램` => `stdout` or `stderr` => 모니터



**printf()**

- printf("`형식 지정자`", 인수1, 인수2, ..., 인수N);
  - 형식 지정자 : 다양한 자료형을 각각의 지정자로 표현 가능



**형식 지정자**

- %c : 문자 한 개
- %d : 부호가 있는 10진수 정수
- %e : 과학 계산용 표기(소문자 e)
- %E : 과학 계산용 표기(대문자 E)
- %f : 10진수 실수
- %g : %e와 %f 중 더 짧은 표현
- %g : %E와 %f 중 더 짧은 표현
- %o : 부호가 없는 8진수 정수
- %s : 문자열
- %u : 부호가 없는 10진수 정수
- %x : 부호가 없는 16진수 정수(소문자)
- %X : 부호가 없는 16진수 정수(대문자)
- %p : 포인터, 메모리의 주소 출력
- %% : % 문자 출력



**제어 문자**

- \n : 줄 바꿈(개행)
- \t : tab
- \b : 이전 문자 지우기
- \r : 줄 맨 앞으로 이동
- \\\, \', \" : \, ', " 문자 출력



**printf() 출력 형식 조정**

- 정수형

  - %자릿수d : 우측 정렬

  - %-자릿수d : 좌측 정렬

    `printf("%5d\n%-10d\n", 123, 9876);`

- 실수형

  - %유효자릿수.소수점이하자릿수f

  - %-유효자릿수.소수점이하자릿수f

    `printf("%6.2f\n%-10.4f>\n", 123.456, 987.1234567);`

    유효자릿수 생략 가능 `%.2f`

- 문자열

  - %자릿수s

  - %-자릿수s

    `printf("%10s\n%-10s\n", "Hello", "Hell");`



**scanf()**

- 프로그램 수행 도중 사용자로부터 입력을 처리해야 하는 경우
- 형식화된 입력 함수로 형식 지정자를 이용하여 다양한 자료형의 데이터를 입력 제공 가능



**형식 지정자**

`scanf("형식 지정자", &변수1, &변수2, ..., &변수N);`

반드시 주소 연산자인 &을 붙여야 함

- %e : 실수 입력
- %f : 실수 입력(float 형)
- %lf : 실수 입력(double 형)
- %g : 실수 입력
- %n : 지금까지 읽어들인 문자 개수 입력

- %[] : [] 사이에 나열된 문자에 해당하는 문자만 입력

- %*c : 엔터 입력 처리



**문자를 입력받아 그 값을 문자, 10진수, 16진수로 출력하기**

```c
int main()
{
    char X;
    scanf("%c", &X);
    scanf("%*c");
    
    printf("%c", X);
    printf("%d", X);
    printf("%x", X);
    
    return 0;
}
```



### 컴파일

**전처리**

`소스 파일` => `컴파일 | 전처리, 문법 체크, 최적화` => `오브젝트 파일` => `링크 | 라이브러리 함수 결합` => `실행 파일`

- 소스 코드를 문법 체크 하기 전 전처리문을 먼저 처리

- 전처리문은 `#`으로 시작되는 명령문으로 소스 코드 재정리

  `#include`, `#define`, `#ifdef`

**이후 오브젝트 파일 생성**

**링크**

- 소스 코드에서 라이브러리 함수를 호출
- 함수의 오브젝트 코드 함께 결합 => 실행 파일 완성
- 라이브러리 함수는 프로그램 작성 시 사용되는 기능을 미리 함수로 정의해놓은 것



### C 컴파일러 옵션 소스 파일명

- C 컴파일러 : Unix(cc), Linux(gcc)

**주요 옵션**

- -o filename : 컴파일 결과를 지정한 filename에 저장
- -c : 오브젝트 파일까지만 생성(.o 또는 .obj 확장자). 여러 개의 소스 파일로 나누어 개발할 때 유용하게 사용

- -l libname : 표준 C 라이브러리가 아닌 그 이외의 라이브러리 결합 시 libname 결합. libname은 라이브러리 파일명 lib_libname.a로 저장
- -g : 실행 파일 디버깅에 필요한 정보가 포함. 디버깅이 필요할 때에는 컴파일 시 이 옵션을 함께 컴파일 해야 함. Visual Studio에서는 디버깅 모드로 빌드하는 방법이 이 옵션

`gcc -o sample sample.c` : 소스 파일 sample.c를 컴파일 하여 실행 파일 sample로 저장

`gcc -c test.c` : 소스 파일 test.c를 컴파일 해서 오브젝트 파일 test.o or test.obj를 생성

`gcc -o hello hello.c -lm` : 소스 파일 hello.c를 컴파일 하고 라이브러리 libm.a를 링크하여 실행 파일 hello 생성



### char 자료형

- ASCII코드 이용 : 표현할 수 있는 기본 문자에 대한 각 코드 값 정의
  - 7비트 인코딩, 33개의 출력 불가능한 제어 문자와 공백을 포함한 95개의 출력 가능한 문자들로 이루어짐
  - 제어 문자들은 역사적인 이유로 남아있고, 대부분 더 이상 사용되지 않음
  - 출력 가능 문자들은 52개 알파벳 대소문자, 32개 특수문자, 1개 공백 문자로 이루어짐

- 8bit(1byte)로 표현 가능
  - 비트(bit, binary digit)
    - 전산학과 정보 이론 분야에서 쓰이고 있는 최소의 정보 단위
    - 이를 대신할 수도 있는 큐비트(qubit)에 대한 연구가 진행 중
    - 하나의 비트는 0이나 1의 값을 가질 수 있고, 참, 거짓이나 서로 배타적인 상태를 나타냄
  - 바이트(byte)
    - 비트가 여러 개 모인 것, 1옥텟인 8비트가 1바이트
    - 4비트는 니블(nibble)이라 부름
    - 2바이트는 일부 전자통신기기에서 워드(word)를 가리킴
    - SI 접두사를 붙여 킬로바이트(KB), 메가바이트(MB), 기가바이트(GB) 등의 용어로 사용



### int 자료형

- 2byte(16bit)의 메모리 공간을 이용했었으나, 32/64bit 운영체제에서는 4byte의 메모리 공간 사용



### float/double 자료형

- 소수점이 포함된 실수를 표현하며 수학적으로 세밀한 연산이 필요할 때 사용
- float은 4byte, double은 8byte의 메모리 공간 사용



### void 자료형

- 값이 없음을 의미하며 표현하기 위한 데이터가 없는 경우에 사용



### 변수

- 데이터를 저장할 수 있는 메모리 공간의 이름



**sizeof()**

- 자료형이나 변수의 메모리 할당 크기를 반환(바이트 단위)
- `int sizeof(자료형);` or `int sizeof(변수);`



### 상수

- 변수는 값이 변경될 수 있는 수, 상수는 변하지 않는 수를 의미

- C에서는 리터럴 상수와 심볼릭 상수를 제공함
  - 리터럴 상수 : 직접 값으로 표현하는 상수
  - 심볼릭 상수 : const 지시어로 선언하는 변수



### 리터럴 상수

- 정수형 상수 : 정수값

  - 1578, -743, 0, 99 등
  - int형으로 간주

- 실수형 상수 : 소수점이 포함되어 있는 실수값

  - 3.141592, 0.00005, -3.3
  - double형으로 간주

  **정수형 상수와 실수형 상수를 정확히 명시하고 싶을 때**

  - 정수형 상수L, 실수형 상수F, 실수형 상수L

  - 각각 long, float, long double

    ```c
    number = 1865;
    real_number = 34.651;
    
    /*
    number = 1865;
    real_number = 34.651F;
    */
    ```

    

- 문자 상수 : 문자 한 개를 상수화

  - 'A', '+', '%', 'b'
  - 바이트의 메모리에 영문자 A를 상수로 표현
  - A 문자를 의미

- 문자열 상수 : 일련의 문자들을 상수화

  - "A", "Korean", "Seoul", "SAMSUNG"
  - 'A'문자와 문자열의 끝을 알리는 '\0'문자를 결합. 2바이트의 메모리에 표현
  - A와 \0 문자열의 시작 주소를 의미함



### 심볼릭 상수

- 상수를 기호화 해서 사용하는 상수, 변수 선언 시 const와 함께 선언

  `const 자료형 변수명 = 초기값;`

- 값을 중간에 변경할 수 없음
- 변수명을 통해 메모리 할당을 받았지만 상수처럼 사용
- 변수의 값을 변경하지 않아야 하는 경우에 많이 사용



### 연산자의 종류

==산술 연산자와 증감 연산자==, ==관계 연산자와 논리 연산자==, ==비트 연산자와 cast 연산자==, ==기타 연산자==

- 괄호 `()`, 배열 `[]`, 구조체 `->` `.`(dot) ==좌 -> 우==
- 단항 : `-`, `!`, `~`, `++`, `--`(type), `&`, `*`, `sizeof()` ==좌 <- 우==
- 산술 `*`, `/`, `%` ==좌 -> 우==
- 산술 `+`, `-` ==좌 -> 우==
- 비트 시프트 `<<`, `>>` ==좌 -> 우==
- 관계 `<`, `<=`, `>=`, `>` ==좌 -> 우==
- 관계 `==`, `!=` ==좌 -> 우==
- 비트 `&` ==좌 -> 우==
- 비트 `^` ==좌 -> 우==
- 비트 `|` ==좌 -> 우==
- 논리 `&&` ==좌 -> 우==
- 논리 `||` ==좌 -> 우==
- 조건(3항) `?:` ==좌 <- 우==
- 대입 `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `>>=`, `<<=`, `&=`, `^=`, `!=` ==좌 <- 우==
- 콤마 `,` ==좌 -> 우==



### 증감 연산자의 위치에 따른 유형

- 전위형 : ++변수명, --변수명
- 후위형 : 변수명++, 변수명--
- 단독으로 전위형과 후위형을 사용할 때는 차이가 없음
- 다른 연산자와 함께 혼용하여 사용할 때는 차이가 있음
  - 전위형 증감 연산자가 포함된 경우 : 변수 값에 대해 증감 연산 => 연산식에 적용
  - 후위형 증감 연산자가 포함된 경우 : 변수 값을 연산식에 적용 => 증감 연산



### 비트 연산자

- 비트를 잘 조작하면 산술 연산보다 더 빠른 속도로 연산 가능
- 메모리의 효율적인 사용을 위해 비트 단위로 데이터를 처리하는 경우
- 장치 제어 프로그램 작성 시 비트 단위의 제어가 필요한 경우
- 시스템 소프트웨어나 운영체제의 커널 프로그램의 경우 필수적
- 여러 속성이 하나의 자료형에 혼합 되어 있을 때, 원하는 속성 값만을 추출, 변경하는 경우

**비트 연산자의 구성**

- `&` : 비트끼리의 AND
- `|` : 비트끼리의 OR
- `~` : 1의 보수 1은 0으로, 0은 1로 변환
- `^` : 비트끼리의 XOR(eXclusive OR) 비트 값이 동일하면 0, 다르면 1
- `>>n` : 오른쪽으로 n비트씩 이동
- `<<n` : 왼쪽으로 n비트씩 이동

**좌변과 우변의 데이터 간에 대응되는 비트끼리 연산한 결과 산출** : 정수형 또는 문자형

```c
int a = 0xec, b = 0x08;
// a = 11101100
// b = 00001000
a & b == 00001000;
/*
	0과 연산하면 0 1과 연산하면 원래 값
	특정 비트를 강제적으로 0으로 만들거나 특정 비트의 값을 확인하는 용도로 사용
*/
a | b == 11101100; 
/*
	0과 연산하면 원래 값, 1과 연산하면 1
	특정 비트를 무조건 세팅하는 용도로 사용
*/
a ^ b == 11100100;
/*
	비트가 서로 다를 때 1, 0과 연산하면 원래 값을 유지
	반전시키고자 하는 부분만 1과 연산하면 원하는 부분만 반전
	반복적인 점멸 처리나 캐럿의 깜박임, 텍스트 블록을 보여주는 용도로 사용
	^ 연산을 반복하면 원형 손상이 없음
*/
~a == 00010011;
/*
	특정 비트를 해제하는 용도로 사용
*/
a >> 2 == 00111011;
a << 2 == 11011000;
/*
	오른쪽으로 이동하면 / 2의 효과,
	왼쪽으로 이동하면 *2의 효과로 산술 연산보다 빠른 계산이 가능
*/
```



### cast 연산자

- C 언어에서는 연산 시 자료형이 다르면 자동적으로 형 변환을 함
- 하지만 명시적으로 형 변환을 하고자 할 때 cast 연산자(형 변환자) 이용

- 선언된 변수의 자료형이 변경되는 것이 아니라 연산이 진행되는 동안만 변경

  `(자료형) 변수명`



### 삼항 연산자

- `?:` 조건에 따라 선택적인 수행

- 결과는 변수에 저장하거나 다른 수식에 포함시킬 수 있음

  `조건식 ? 식1:식2`

  - 참일 경우 식1, 거짓일 경우 식2



### 사용자 정의 자료형

- typedef : 사용자가 새로운 자료형의 이름을 선언할 수 있도록 해주는 명령문

  - 기존에 있는 자료형에 이름만 부여하는 것

    ```c
    typedef 기존자료형명 새로운자료형명;
    
    typedef int number_t;
    number_t count; // int count와 동일
    ```

- enum(나열형) 자료형 : 하나 이상의 정수형 상수를 원소로 갖는 집합

  - enum 목록에 나열된 것은 정수형 상수

  - enum 자료형으로 선언한 변수는 정수형 변수와 동일하게 처리

    ```c
    enum tag_name { enum 목록 } 변수명;
    
    enum weekday { sun, mon, tue, wed, thu, fri, sat } day;
    /*
    	enum weekday : day 변수의 자료형
    	sun ~ sat은 각각의 index 번호를 나타냄(0 ~ 6)
    	각각의 값은 사용자가 지정할 수 있음
    */
    enum weekday { sun = 10, mon, tue, wed, thu, fri, sat } day;
    // 이 경우 mon ~ sat은 11 ~ 16의 값을 가짐
    
    day = sun;
    (day == sat) ? count1++:count2++;
    
    day = mon;
    printf("오늘은 %d요일입니다.\n", day);
    ```

  - 소스 코드 작성 시 가독력이 좋은 프로그램 작성 가능

  - 숫자로 값을 지정할지, 심볼릭한 문자를 사용할지 선택하면서 프로그램 분석이 용이하게 만듦



### 프로그램의 구조

- 차례대로 수행되는 순차적인 구조
  - C 언어의 규칙에 따라 차례대로 나열
- 조건에 따라 수행되는 선택 구조
- 일정한 조건에 따라 여러 번 수행되는 반복 구조
  - 위 2가지는 제어문으로 표현됨
  - 프로그램의 수행 순서를 변경
  - 조건식의 수행 결과에 따라 참 또는 거짓으로 나뉨
  - 참과 거짓이 수행되는 부분은 서로 구분되어 처리됨



### 프로그램의 흐름을 표현하는 방법

- 사람의 사고, 즉 논리를 표현하는 데 적합한 절차적인 프로그램 언어
- 문제 해결 방법을 논리로 정리한다면 좀 더 쉽게 구현
  - 문제해결 방법은 순서도의 기호를 이용하여 표현할 수 있음
  - 프로그램의 흐름, 즉 논리를 기호로 이해하기 쉽게 표현하는 방법
  - 논리를 표현하는 방법은 Flow-Chart, NS-Chart, Pseudo Code 등이 있다

- Flow-Chart의 기호
  - 네모 : 순차 구조의 명령문을 표현하는 기호
  - 마름모 : 조건을 판별해야 할 때 이용하는 기호
  - 화살표 : 프로그램의 흐름을 나타내는 연결자 기호
  - 타원 : 프로그램의 시작과 종료를 표현하는 기호
  - 원 : 프로그램의 흐름을 연결하는 연결자 기호



### switch 문의 사용

- 여러 개 중 하나를 선택하는 구조에서 다중 if 문 대신 switch 문을 이용할 수 있음
- 조건식의 수행 결과가 참이나 거짓이 아니라 특정 값으로 나오는 경우
  - 소스 프로그램을 이해하기 쉽고 나중에 변경이 용이



### if와 switch의 차이

- if 문

  - 조건식을 처음부터 일일이 비교해 나가는 방식
  - 다중 if 문으로 구현해야만 하는 경우가 있음

- switch 문

  - 코드를 읽고 분석, 수정하기 더 편리함
  - 실행 속도 면에서도 좀 더 우수함
  - 여러 case 중 하나만 선택되어 실행하는 구조이기 때문에 성능이 우수함
  - case에서 정수 및 문자 상수만 사용 가능

  ```c
  switch (조건식)
  {
      case 값1:
          명령문 1-1;
          break;
      case 값2:
          명령문 2-1;
          break;
      default:
          명령문 n-1;
          break;
  }
  ```



### goto 문 사용

- 프로그램 실행 도중 어느 특정 위치로 이동해야 하는 경우
- goto 문을 만나면 label(레이블)이 있는 위치로 무조건 이동
  - 사용 전에 label을 설정해야 한다
- 반복문 안에 반복문이 여러 번 중첩되어 있는 경우 한 번에 반복문을 모두 벗어날 수 있다
- goto 문을 잘못 사용하면 프로그램의 무한 반복이나 예상치 못한 수행이 진행될 수 있다
- 잘 구성된 프로그램이라면 goto문을 사용하지 않는 것이 좋다

 

### do-while 문

- while 문과 유사한 반복문

- 차이점

  - 반복 여부를 결정짓는 조건식이 반복문 뒤쪽에 있어서 반복 수행할 명령문을 먼저 수행한 후 반복을 계속할지를 결정

- 최소 1번 이상 반복 명령문을 수행하는 구조라면 do-while 문 사용

  - 처음 시작할 때 메뉴를 출력하고 사용자 선택을 기다림
  - 사용자 선택에 따라 반복 여부가 결정되기 때문에 사전에 사용자 선택을 입력 받아야 한다.

  ```c
  do
      명령문;
  while (조건식);
  
  do {
      명령문1;
      명령문2;
  } while (조건식);
  ```

  

### 함수

- 함수(function), 서브루틴(subroutine), 루틴(routine), 메서드(method), 프로시저(procedure)는 소프트웨어에서 특정 동작을 수행하는 일정 코드 부분을 의미함

- 함수의 구성요소
  - 함수 원형 선언(Declaration)
  - 함수 정의(Definition)
  - 함수 호출(Call), 실행



### 함수 원형 선언

- 함수의 원형을 컴파일러에게 미리 알려주어 원형에 맞지 않은 잘못된 사용을 방지하기 위한 것

- 프로그램의 소스 코드에서 원형에 맞지 않는 함수를 사용할 경우, 컴파일 시 오류 메시지를 띄워 정확하게 사용하도록 함

  **리턴자료형 함수명([자료형 매개변수, ...]);**

  - 리턴자료형
    - 함수의 수행 결과를 반환할 때 자료형 명시(int, char, float, double, void)
  - 함수명
    - 함수를 구분하는 요소
    - 프로그램 내에서 유일하게 구성해야 함
    - 영어 대소문자와 숫자, `_`로 구성
  - 자료형 매개변수
    - 함수 호출시 전달하는 인자가 있을 때 인자 하나하나에 대응하여 기술
    - 자료형은 반드시 기술해야 하고 매개변수 이름은 생략 가능하다
    - 인자 전달이 없는 함수는 매개변수 목록을 생략하거나 명시적으로 void 기술



### 함수 정의

```c
리턴자료형 함수명([자료형 매개변수, ...])
{
    명령문1;
    명령문2;
}
```



### 함수 호출

**[변수=] 함수명([인자, ...]);**

- 반환값이 있는 함수 : 리턴 자료형에 맞게 변수를 선언하고 결과를 변수에 대입 가능



### 함수 호출 시 인자 전달

- 함수 호출 시 전달되는 인자들이 함수의 매개변수로 대입되는 것



**인자를 전달하는 방식**

- 값에 의한 호출(Call by Value)
  - 함수 호출 시 실제로 전달되는 인자들이 함수의 매개변수로 대입되는 것
  - 변수 선언은 메모리의 할당을 의미, 매개변수를 위한 할당된 메모리로 인자 값들이 저장됨
  - 매개변수를 변경하는 것은 인자나 호출한 함수에 영향을 주지 않음
- 참조에 의한 호출(Call by Reference)
  - 인자를 넘길 때 주소 연산자인 `&`를 붙여서 넘김
  - 함수를 정의할 때는 포인터 자료형인 `*`을 붙여서 정의



### 매크로

- 배열은 선언 시 정해진 크기 만큼 반복적인 작업을 많이 수행하기 때문에 매크로로 정해두는 것이 편하다

```c
// 반복문을 사용할 경우
int num[10];

for (int i = 0; i < 10; ++i)
{
    ...
}

// 매크로를 사용할 경우
#define MAX 10;
int num[MAX];

for (int i = 0; i < MAX; ++i)
{
    ...
}
```



### 전처리 구문

- `#include`, `#define`, `#if ~ #endif`등과 같이 #으로 시작하는 명령문을 전처리 구문이라 함
- 컴파일러가 컴파일 하기 앞서 소스 코드를 정리하는 데 이용되는 명령문들

- `#include` : 다음에 오는 헤더 파일을 소스 코드에 포함 (`#include <stdio.h>`)
- `#define` : 소스 코드 중 다음에 지정된 매크로명으로 되어 있는 부분을 모두 매크로명 뒤에 정의된 값으로 수정
- `#if~#endif` : 이 명령문 사이에 오는 명령문들은 조건에 따라 소스 코드에 포함(1) 또는 제외(0)



### C 언어의 문자열 처리 함수

- 문자열을 비교하거나 문자 개수를 알아야 하는 경우 라이브러리 함수 형식으로 제공되므로 바로 사용 가능

- `char *strcpy(char* dest, const char* src);`
  - src의 문자열을 dest의 배열로 복사하는 문자열 복사 함수
- `char *strcat(char* dest, const char* src);`
  - dest가 가리키는 문자열 뒤에 src가 가리키는 문자열을 덧붙이는 함수
  - `if (strlen(A) + strlen(B) < sizeof(A) / sizeof(A[0]))`
    - A문자열 길이 + B문자열 길이를 A배열의 메모리 길이 / A배열 원소 하나의 길이와 비교
- `int ctrcmp(const char* s1, const char* s2);`
  - s1과 s2가 가리키는 문자열을 비교하는 함수
  - 반환 값 : 0(문자열이 동일), > 0(s1이 큰 경우), < 0(s2가 큰 경우)
- `size_t strlen(const char* s);`
  - 문자열 길이를 바이트 단위로 계산해서 반환(널 문제 제외)



**문자열을 입력 받아 배열에 추가하기**

```c
#include <stdio.h>
#include <string.h>

int main()
{
    char arr[500] = "";
    char string[80];
    int max = sizeof(arr) / sizeof(arr[0]);
    while(1) {
        printf("문자열을 입력하세요 --> ");
        scanf("%s", string);
        if (strcmp(string, "end") == 0)
            break;
        if ((strlen(arr) + strlen(string) + strlen(", ")) < max)
        {
            strcat(arr, string);
            strcat(arr, ", ");
        }
    }
    printf("arr : [ %s ]\n", arr);
    
    return 0;
}
```



### 기본 자료형 메모리

- float : 소수점 이하 6자리 실수 표현에 적절한 자료형

  - 4byte(32bit) 할당 받음
  - 31bit는 부호 비트
  - 30 ~ 23bit는 지수부(Exponent)로 소수점 위치 풀이
  - 나머지는 가수부(Mantissa)로 유효 숫자 표현
  - 지수부의 표기는 가수부에 곱해지는 2의 거듭제곱수를 나타내고 각 표기법에서 표현 가능한 최대값은 지수부에 의해 결정된다

  - 8bit에 해당되기 때문에 2^128^ = 10^38^으로 표현 가능한 수의 범위는 10^-38^ ~ 10^38^

- double : 소수점 이하 15자리 실수 표현에 적절한 자료형
  - 8byte(64bit) 할당 받음
  - 63bit는 부호 비트
  - 62 ~ 52bit는 지수부, 나머지는 가수부
  - 지수부가 11bit기 때문에 2^1024^ = 10^308^으로 표현 가능한 수의 범위는 10^-308^ ~ 10^308^



### unsigned

- 기본 자료형인 char와 int는 사실 signed char와 signed int로 맨 왼쪽 비트를 부호 비트로 사용
- 표현하려는 데이터에 음수가 없을 경우에는 unsigned char, unsigned int로 선언해 더 많은 범위를 사용



### short/long

- int는 4byte 메모리를 할당받기 때문에 4byte까지의 수가 모두 필요하지 않을 경우 short int를 선언해 2byte를 할당받는다
  - 16bit OS에서는 int에 2byte를 할당, 32bit에서는 4byte를 할당 long int와 int의 크기가 동일
  - 64bit에서도 int는 4byte지만 long int는 8byte
  - 32bit : long int(-2,147,483,648 ~ 2,147,483,648), unsigned long int(0 ~ 4,294,967,295)
  - 64bit : long int(-9,223,372,036,854,775,808 ~ 9223,372,036,854,775,808), unsigned long int(0 ~ 18,446,744,073,709,551,614)
- long double형 변수는 8byte 이상의 메모리를 할당받지만 컴파일러마다 제공하는 크기가 다를 수 있음



### 프로세스

- 프로그램 실행 시 운영체제에서 프로그램이 동작될 수 있는 메모리 공간 할당 시 이 메모리 공간에서 실행 중인 프로그램

- 프로세스 메모리 공간의 영역 구성

  - Stack Segment : 지역변수 및 리턴 주소
    - 함수 내에서만 사용 가능한 지역 변수 및 함수 수행 종료 시 되돌아갈 주소 할당
  - Heap Segment : 동적으로 할당되는 메모리
    - 프로그램 실행 시 동적으로 할당되는 공간
  - Data Segment : 전역 변수 및 static 변수
    - 프로그램 전 영역에서 사용 가능한 전역 변수 및 static 변수 할당
  - Code Segment 또는 Text Segment : 프로그램의 실행 코드
    - 변경되지 않는 영역, 읽기 전용 공간으로 할당

  **이 중 Data Segment의 전역 변수와 Stack Segment의 지역 변수는 변수 선언 위치에 따라 결정**



### 지역 변수, 전역 변수

- 지역 변수
  - 함수 내에서 선언된 변수
  - 함수 호출 시 인자를 받아오는 매개 변수
  - 변수가 선언된 함수 내에서만 사용
  - 다른 함수에서는 참조 불가
  - 함수 실행 시 함수에 대한 정보와 함께 Stack Segment에 생성 후 함수 종료 시 소멸
- 전역 변수
  - 함수 회부에 선언된 변수
  - 프로그램 전체에서 함께 사용 가능
  - 같은 프로그램 내 어떤 함수든 같은 변수명을 이용하여 공유
  - Data Segment는 프로그램 종료 시까지 소멸되지 않음



### static

- 함수 내에서만 사용하지만 함수가 종료되어도 값을 유지하고 싶을 경우에 사용

- 전역 변수와 같은 Data Segment에 메모리를 할당받으므로 함수 종료 후에도 Stack Segment에 있는 지역 변수들만 소멸

  `static 자료형 변수명`

- static 전역 변수 : 해당 전역 변수를 다른 소스 파일에서 참조할 수 없도록 제한할 때 사용

  - 팀 프로젝트에서 여러 소스 파일을 사용하게 됐을 때, 내가 사용하는 전역 변수 이름이 다른 사람이 만든 전역 변수 이름과 동일하면 같은 변수를 공유하게 할 수 있음. 내가 선언한 전역 변수를 내 소스 파일 안에서만 사용하고 싶을 때 static 전역 변수 이용



### 포인터

- C 언어에서 포인터를 사용하는 경우
  - 프로그램이 실행되는 동안 메모리의 할당을 받아 자료들을 연결 리스트(linked-list)나 이진 트리(binary-tree) 등의 자료구조를 구성할 때 사용
  - 주변 장치의 드라이버 작성 시 장치와의 통신 방법이 메모리를 통해 일어나면(memory-mapped I/O) 포인터를 사용하여 메모리 공간 제어

- 포인터 변수의 연산
  - +, -, ++, --
  - 메모리 주소가 저장되기 때문에 주소를 연산함
  - 주소는 모두 정수로 구성되기 때문에 실수형 연산은 할 수 없음
  - 포인터 변수 자료형의 크기만큼 연산

- 포인터 연산의 우선 순위
  - `*p+1` : `(*p)+1`, p가 가리키는 메모리의 내용에 1을 더한다
  - `*(p+1)` : p의 주소에 1을 더한다
  - `*p += 1` : `(*p) = (*p)+1`, p가 가리키는 메모리의 내용에 1을 더하고 대입
  - `*p++` : `*p; p++;`, p가 가리키는 메모리의 내용 참조 후 주소 증가
  - `(*p)++` : p가 가리키는 메모리의 내용에 1을 더한다
  - `*++p` : `*(++p)`, p의 주소를 1 증가시킨 후 그 번지 내용을 참조한다
  - `++*p` : `++(*p)`, p가 가리키는 메모리의 내용에 1을 더한다



**문자열 전용 입출력 함수**

- `char* gets(char* s);` : 문자열 입력 함수
- `int puts(const char* s);` : 문자열 출력 함수



### 2차원 배열과 포인터

```c
int count[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
int* ip;
ip = count;
```



### 동적 메모리 할당

- 변수 및 배열 선언
  - 프로그램 실행 시 미리 고정된 크기의 메모리가 할당 된 상태기 때문에 데이터 개수가 유동적일 경우 불필요한 공간을 크게 확보하거나 일정 개수 이상 관리가 불가한 경우가 발생

**동적 메모리 할당 함수**

- `#include <stdlib.h>`을 선언해야 동적 메모리 할당 가능

`void* malloc(size_t size);`, `void* calloc(size_t nmemb, size_t size);`, `void* realloc(void* ptr, size_t size);`

- `void* malloc(size_t size);`
  - size에 명시된 크기만큼 메모리를 할당 받는 함수
  - size는 메모리 할당 크기(바이트 수 기준)

- `void* calloc(size_t nmemb, sizt_t size);`
  - nmemb * size 크기만큼 메모리를 할당 받는 함수
  - nmemb : 자료형의 크기, size : 개수
  - 할당 받은 메모리를 모두 0으로 초기화까지 해주는 함수
- `void* realloc(void* ptr, size_t size);`
  - 이미 동적 할당을 받아 사용 중인 공간을 다시 재할당 받아야 할 때 사용
  - ptr : 기존에 사용하던 메모리의 시작 주소, size : 재할당을 원하는 크기

- **세 함수 모두 포인터 변수로 받아옴, `void*`은 함수 원형에 제공된 리턴 타입으로 반환 값을 포인터 변수에 대입하여 사용**

- **동적 메모리는 Heap Segment에 공간을 할당 받고, free 함수로 해제하지 않는 한 계속 메모리를 점유하기 때문에 주소만 알아도 다른 함수에서 해당 메모리 공간을 사용할 수 있음**

- 메모리 공간 확보 실패 시 NULL 반환



**free 함수**

`void free(void* ptr);`

- ptr 포인터 변수가 가리키는 메모리를 해제하는 함수
  - 반드시 동적 할당 받은 메모리의 시작 주소를 넘겨줘야 함
    - 시작 주소가 아닌 주소를 인자로 전달 시 함수 수행시 오류 발생
  - 동적 할당 받은 메모리는 이 함수로 해제해야 함
    - 해제하지 않을 경우 메모리 누수 현상 발생 가능



### 다중 포인터

**`자료형 변수명`**으로 선언

- `int** dptr = (int**) malloc(sizeof(int*));`
  - 포인터 변수 dptr이 가리키는 메모리 조회 시 해당 위치에도 다른 곳을 가리키는 주소가 있어야 함

- 사용하는 경우

  - 함수 안에서 할당한 메모리의 주소를 되돌려줘야 할 때

  ```c
  // 두 번째 매개 변수로 넘어온 size 만큼의 메모리를 동적으로 할당 받음
  // 이 함수에서 할당 받은 주소를 main 함수에서 호출 시 전달한 인자(dptr) 변수에 되돌려줘야 한다
  int create_darray(int** ptr, int size)
  {
      int* tptr = (int*) calloc(sizeof(int), size);
      
      if (tptr == NULL)
          {
              // 오류 처리
          }
      *ptr = tptr;
      return 0;
  }
  
  int main()
  {
      int* dptr;
      
      // call by reference
      // dptr 포인터 변수의 주소(&dptr)를 인자로 전달
      create_darray(&dptr, 10);
  	return 0;
  }
  ```

  

### main 함수의 원형

`int main(int argc, char* argv[])`

- 프로그램 실행 시 인자를 전달받기 위해 main 함수의 원형에 대한 이해 필요



### 함수 포인터

- 포인터에 함수의 시작 번지를 넣어서 사용할 수 있음
- 포인터 변수에 함수를 대입하고 포인터 변수를 이용해 함수를 호출하는 것을 함수 포인터라 함

- 사용하는 경우
  - 다양한 함수들이 서로 다른 환경에서 호출되어야 하는 경우
    - 컴파일러, 어셈블러, 인터프리터 등의 시스템 소프트웨어 작성 시
  - 동적으로 함수를 불러서 사용하고 필요 없는 경우 삭제하는 동적 라이브러리 함수를 이용해야 하는 경우



**함수 포인터 변수 선언 방법**

`리턴타입 (*함수포인터변수명) (매개변수목록);`

- *함수 포인터 변수명 : 포인터 변수로 선언하기 위한 것

- 매개 변수 목록 : 함수의 기본 형식에 해당, 안에 매개 변수를 선언

  ```c
  // int (*fun) int);도 가능, 매개 변수 명은 생략 가능
  // fun은 함수 포인터 변수로 시작 주소를 대입하여 사용할 수 있음
  // int 값을 반환하고 매개 변수는 int형의 num 하나만 선언해야 한다
  int (*fun) (int num);
  ```



**함수 시작 주소 확인**

- 배열 이름 = 배열 시작 주소
- 함수 이름 = 함수 시작 번지
- 함수 포인터 변수에 함수 명을 대입하면 함수 코드가 있는 메모리 위치를 지칭
- 함수 포인터 변수의 원형과 함수 원형이 일치하지 않으면 주소 대입 불가



### 함수 포인터 배열

- 배열 원소 각각이 함수 포인터 변수인 것
- 원형이 동일한 함수의 주소들이 모여있는 구조

`리턴타입 (*함수포인터배열명[크기]) (매개 변수 목록);`



### void 포인터

`void* malloc(size_t size);`

- void* : malloc 함수의 리턴 타입
- void형
  - 값이 없을 때 이용하는 자료형
  - 반환 값이 없는 함수의 리턴 타입
- void*형
  - 주소를 저장하는 자료형
  - 어떤 유형의 주소도 저장 가능
    - `int num; char ch; void* p; p = &num; p = &ch;`
  - void형은 크기가 없어 void* 변수가 가리키는 메모리를 얼마나 참조해야 하는지 확인 불가
    - 포인터가 가리키는 내용 참조 시 원래 자료형으로 형 변환
    - `printf("num = %d\n", *(int*)p);` p변수 앞에 (int*) 형 변환 연산자 없으면 컴파일 오류



### 라이브러리 함수

- 표준 입출력

  ```c
  #include <stdio.h>
  
  char * gets(char *s);
  /*
  	인자로부터 전달받은 메모리의 시작 주소에 표준 입력으로부터 받은 문자열을 저장
  	메모리 크기를 초과하는 문자열을 입력받는 경우 함수 내에서 통제되지 않음
  	scanf와 다르게 공백 문자까지 모두 입력된다
  */
  
  int getchar();
  // 표준 입력으로 한 글자를 입력 받는 함수
  
  int scanf(const char* format, ...);
  int sscanf(const char*s, const char* format, ...);
  /*
  	형식화된 입력에 사용되는 함수
  	format에 형식 지정자의 목록을 작성하고 그에 따른 인자 전달
  	scanf 함수는 표준 입력 장치로부터, sscanf 함수는 첫 번째 인자인 s에 전달된 문자열로부터
  	형식 지정자에 대응되는 순서대로 입력을 받음
  */
  
  int puts(const char* s);
  // s에 전달된 문자열을 표준 출력장치로 출력하는 함수
  
  int putchar(int c);
  // c로 전달된 문자를 표준 출력장치로 출력하는 함수
  
  int printf(const char* format, ...);
  int sprintf(char* s, const char* format, ...);
  /*
  	형식화된 출력 함수
  	형식 지정자의 목록을 format에 명시하고 그에 대응되는 인자 전달
  	printf 함수의 수행 결과는 표준 출력장치인 모니터로, sprintf 함수의 수행 결과는 첫 번째 인자로 전달된 메모리로 저장
  	sprintf 함수를 이용할 때에는 수행 결과가 저장될 메모리의 크기가 충분한지 확인해야 함
  */
  ```

- 문자열 처리 함수

  ```c
  #include <ctype.h>
  
  int isalnum(int ch);
  // 인자가 영문이나 숫자인 경우 참(0이 아닌 값) 반환, 그렇지 않은 경우 거짓(0) 반환
  
  int isalpha(int ch);
  // ch가 영문인 경우 참, 아닌 경우 거짓
  
  int isdigit(int ch);
  // ch가 숫자(0 ~ 9)인 경우 참, 아닌 경우 거짓
  
  int iscntrl(int ch);
  // c에 전달된 인자가 0 ~ 0x1f 사이에 있거나 0x7f(DEL)과 같은 제어 문자인 경우 참, 아닌 경우 거짓
  
  int isspace(int ch);
  // ch가 공백이면 참, 아니면 거짓
  
  int ispunct(int ch);
  /*
  	ch가 공백을 제외한 구두점 문자인 경우 참, 아니면 거짓
  	구두점 문자 : 영문, 숫자, 공백을 제외한 출력 가능 문자, 즉 특수문자
  */
  
  int tolower(int ch);
  int toupper(int ch);
  // ch가 영문자인 경우 소문자, 대문자 반환, 영문자 아닌 경우 ch 반환
  ```

- 문자열 처리 함수

  ```c
  #include <string.h>
  
  char* strcat(char* str1, const char* str2);
  char* strncat(char* str1, const char* str2, size_t size);
  /*
  	str2의 문자열을 str1의 문자열에 추가
  	strcat : str2 문자열 전체를 추가
  	strncat : str2 문자열 중 size 만큼만 추가, str1의 메모리 공간을 고려하지 않기 때문에 개발자가 크기 고려를 책임져야 함
  */
  
  char* strcpy(char*str1, const char* str2);
  char* strncpy(char* str1, const char* str2, size_t size);
  /*
  	str2 문자열을 str1로 복사할 때 사용
  	strcpy : str2 문자열 전체 복사
  	strncpy : size만큼만 복사
  	str1의 메모리 고려가 필요
  */
  
  char* strdup(const char* s);
  /*
  	내부적으로 malloc 함수로 동적 할당을 받은 메모리에 인자로 전달된 문자열 s를 복사 후 시작 주소 반환
  	이 함수로 문자열을 복사한 경우, 필요 없게 되었을 때 free 함수로 반환해야 함
  	에러 발생 시 NULL 반환
  */
  
  int strlen(const char* str1);
  // str이 가리키는 문자열 길이 반환, \0 제외
  
  int strcmp(const char* str1, const char* str2);
  int strncmp(const char* str1, const char* str2, size_t size);
  /*
  	str1과 str2 비교
  	strcmp : 두 문자열의 길이나 내용이 모두 일치하는지 비교
  	strncmp : size만큼 사전식으로 비교해서 결과를 정수로 반환, 일치하면 0 아니면 0 아닌 값
  */
  
  char* strchr(const char* str, int ch);
  char* strrchr(const char* str, int ch);
  /*
  	str이 가리키는 문자열에서 문자 ch가 처음으로 나타나는 곳의 주소 반환
  	strchr 함수는 문자열의 시작 부분부터, strrchr는 문자열의 마지막 문자부터 거꾸로
  	일치하는 것이 없을 경우 NULL 포인터 반환
  */
  
  char* strstr(const char* str1, const char* str2);
  // str1이 가리키는 문자열에서 str2 문자열이 포함된 곳의 주소 반환, 없으면 NULL 포인터 반환
  
  char* strtok(char* str1, char* str2);
  /*
  	str1이 가리키는 문자열에서 토큰에 대한 위치를 주소로 반환하는 함수
  	str2가 가리키는 문자열은 토큰을 구분하기 위한 구분자의 목록
  	더 이상 반환할 토큰이 없으면 NULL 포인터 반환
      이 함수가 처음 호출할 때는 str1을 명시하지만 그 다음부터는 NULL을 명시함
  */
  ```

- 시간 관련 함수

  ```c
  #include <time.h>
  
  struct tm {
  	int tm_sec; // 초 0 ~ 59
      int tm_min; // 분 0 ~ 59
      int tm_hour; // 시 0 ~ 23
      int tm_mday; // 일 1 ~ 31
      int tm_mon; // 1월부터의 월 0 ~ 11
      int tm_year; // 1900년부터의 년
      int tm_wday; // 일요일부터의 요일 0 ~ 6 
      int tm_yday; // 1월 1일부터의 날 수 0 ~ 365
      int tm_isdst; // 낮 절약 표시 시간
  }
  
  
  time_t time(time_t* time);
  // 시스템의 현재 시각을 long형의 time_t로 반환, 시간 관리 기능이 없는 시스템은 -1 반환
  
  char ctime(const time_t* timep);
  // 시스템의 현재 시각을 사용자가 알아보기 쉬운 문자열로 반환
  
  char* asctime(const struct tm* ptr);
  // struct tm형의 시간 정보를 전달 받아 사용자가 알아보기 쉽게 문자열로 변환
  
  char* difftime(time_t time2, time_t time1);
  // time1과 time2의 시간 간격을 초 단위로 반환
  
  struct tm* localtime(const time_t* timep);
  // time_t형의 시간 정보를 전달 받아 struct tm 자료형으로 변환한 시간 정보 반환, 시간 정보 연산이 필요한 경우 사용
  ```

- 동적 메모리 할당 함수

  ```c
  #include <stdlib.h>
  
  void* malloc(size_t size);
  // size만큼의 메모리를 Heap Segment에 할당 받아 그 시작 주소를 반환, 메모리 공간 부족은 NULL 포인터 반환
  
  void* calloc(size_t num, size_t size);
  /*
  	num * size 크기의 메모리를 Heap Segment에 할당 받아 시작 주소 반환
  	자동으로 0으로 초기화, 공간 부족은 NULL 포인터 반환
  */
  
  void free(void* ptr);
  // 동적 할당 받은 메모리를 해제하는 함수
  
  void* realloc(void* ptr, size_t size);
  /*
  	ptr이 가리키는 메모리 크기를 size만큼의 크기로 조정하는 함수
  	크기가 커지는 경우 블록이 이동될 수 있으며 새로 할당된 시작 주소 반환
  	이전 블록 내용은 모두 새로운 블록으로 복사, 공간 부족은 NULL 포인터 반환
  */
  ```

- 메모리 처리 함수

  ```c
  #include <string.h>
  
  void* memcpy(void* to, const void* from, size_t size);
  /*
  	from이 가리키는 메모리로부터 to가 가리키는 메모리로 size만큼 복사
  	from과 to가 중첩될 경우 이 함수 대신 memmove 함수 사용
  */
  
  void* memmove(void* to, const void* from, size_t size);
  // 2개 메모리 공간이 중첩될 경우에도 from이 가리키는 메모리에서 to가 가리키는 메모리로 size만큼 복사
  
  void* memset(void* to, int c, size_t size);
  /*
  	to가 가리키는 메모리로부터 size만큼의 메모리에 c에 전달된 값을 unsigned char로 변환하여 복사
  	주로 메모리 초기화 시 사용
  */
  ```

  

### 구조체

- 구조체 변수 선언은 구조체 자료형에 대한 선언부터 해야 한다

  ```c
  struct 태그명 {
  	자료형 멤버변수1;
      자료형 멤버변수2;
  };
  
  
  struct score {
      char name[20];
      int kor;
      int math;
      int eng;
      float avg;
  };
  
  
  typedef struct score {
  	char st_name[20];
      int kor;
      int math;
      int eng;
      float avg;
  } SCORE; // SCORE는 자료형의 이름
  ```



**구조체 변수 선언 방법**

```c
// 구조체 자료형의 선언과 변수 선언을 함께 하는 방법
struct typeA {
	int mem1;
    float mem2;
} var;

// 구조체 자료형의 선언과 변수 선언을 따로 하는 방법
struct typeB {
	int mem1;
    float mem2;
};
struct typeB var;

// 태그명을 붙이지 않고 자료형과 변수를 동시에 선언하는 방법
struct {
	int mem1;
    float mem2;
} var;
```



**구조체 변수 초기화**

- 방법 : 중괄호 사이에 각 멤버의 초기값을 `,`로 나열

- 순서 : 구조체에 선언된 멤버의 순서대로 나열

  `struct score student = { "kim", 90, 85, 93, 0.0 };`



### 구조체 배열

- 관련된 구조체를 배열로 묶어서 사용

  `struct score st[30];`

  - 각 원소마다 score 구조체를 생성



### 구조체 포인터 변수

`구조체자료형* 구조체포인터변수명;`

```c
typedef struct member {
    int id;
    char name[20];
} MEMBER;

MEMBER* ptr;
MEMBER person;
ptr = &person;

// 구조체 포인터 변수 ptr을 통해 멤버를 표현하는 경우
ptr -> id;
ptr -> name;

scanf("%d", &ptr -> id);
gets(ptr -> name);
```



### 동적 메모리와 구조체 포인터 변수

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX 10

int main()
{
    typedef struct member {
        int id;
        char name[20];
    } MEMBER;
    
    int i, count;
    MEMBER* ptr;
    MEMBER* parray[MAX];
    
    for (i = 0; i < MAX; ++i)
    {
        ptr = (MEMBER*)malloc(sizeof(MEMBER));
        if (ptr == NULL)
        {
            printf("메모리를 더 이상 할당할 수 없습니다.\n");
            return 1;
        }
        printf("ID 입력 : ");
        scanf("%d%*c", &ptr->id);
        if (ptr -> id == -1)
        	break;
        printf("이름 입력 : ");
        gets(ptr -> name);
        parray[i] = ptr;
    }
    count = i;
    for (i = 0; i < count; ++i)
    {
        printf("id : %d, name : %s\n", parray[i] -> id, parray[i] -> name);
    }
    free(ptr);
    for (i = 0; i < count; ++i)
        free(parray[i]);
    return 0;
}
```



### 자기 참조형 포인터

- 중첩된 구조체 : 구조체 안에 또 다른 구조체를 하나의 멤버로 포함 시키는 것

  ```c
  struct id_type {
      int age;
      char addr[80];
      struct member info;
  } people;
  ```

- 자기 참조형 구조체

  ```c
  typedef struct member {
      int id;
      char name[20];
      struct member* next;
  } MTYPE;
  MTYPE people1, people2;
  people1.next = &people2;
  ```

  - 변수의 선언, 동적 메모리 할당 함수 사용은 메모리 할당을 의미



### 공용체

- 같은 메모리 공간을 여러 멤버가 공유하는 형태

- 메모리 공간은 멤버 변수 중 가장 큰 자료형 만큼 할당됨

  ```c
  union 태그명 {
      자료형 멤버변수명1;
      자료형 멤버변수명2;
  } 변수명;
  
  union entype {
      short num;
      char xy[2];
  } code;
  code.num = 0x4142 // code.xy[0]에는 0x42, code.xy[1]에는 0x41이 조회
  ```



**바이트 순서**

- CPU 아키텍처에 따라 데이터를 메모리에 저장하고 읽어오는 순서(호스트 바이트 순서)가 다를 수 있음
  - 빅엔디안 방식 : 낮은 번지에서부터 데이터를 저장
  - 리틀엔디안 방식 : 높은 번지에서부터 데이터를 저장
- 4byte int 형 변수 `num = 0x41424344;` 입력 시
  - 리틀엔디안(인텔 계열) : 0x1000에 0x44, 0x1003에 0x41이 저장됨
  - 빅엔디안(RISC,  SPARC 등) : 0x1000에 0x41, 0x1003에 0x44가 저장됨
- 빅엔디안 방식은 가독성이 뛰어나고 대소비교가 빠르다는 장점이 있음
- 리틀엔디안 방식은 산술연산이 빠르다는 장점이 있음
- 통신 프로그램 작성 시에는 호스트 바이트 순서 문제가 중요한 요소가 됨















